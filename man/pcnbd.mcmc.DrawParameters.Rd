% Generated by roxygen2 (4.0.0): do not edit by hand
\name{pcnbd.mcmc.DrawParameters}
\alias{pcnbd.mcmc.DrawParameters}
\title{Hierarchical Bayes implementation of Pareto/CNBD}
\usage{
pcnbd.mcmc.DrawParameters(cal.cbs, mcmc = 1500, burnin = 500, thin = 1,
  chains = 2, param_init = list(t = 1, gamma = 1, r = 1, alpha = 1, s = 1,
  beta = 1), hyper_prior = list(t_1 = 1/1000, t_2 = 1/1000, gamma_1 = 1/1000,
  gamma_2 = 1/1000, r_1 = 1/1000, r_2 = 1/1000, alpha_1 = 1/1000, alpha_2 =
  1/1000, s_1 = 1/1000, s_2 = 1/1000, beta_1 = 1/1000, beta_2 = 1/1000))
}
\arguments{
\item{cal.cbs}{data.frame with columns 'x', 't.x', 'T.cal', 'litt'; e.g. output of \code{\link{elog2cbs}}}

\item{mcmc}{number of MCMC steps}

\item{burnin}{number of initial MCMC steps which are discarded}

\item{thin}{only every thin-th MCMC step will be returned}

\item{chains}{number of MCMC chains to be run}

\item{use_data_augmentation}{determines MCMC method to be used}

\item{param_init}{list of 2nd-level parameter start values}

\item{hyper_prior}{list of hyper parameters for 2nd-level parameters}
}
\value{
2-element list
level_1:  list of coda::mcmc.list objects; one for each customer, containing individual-level draws
level_2:  coda::mcmc.list object containing draws of heterogeneity parameters
}
\description{
Returns 2-element list
  level_1:  3-dim array [draw x parameter x cust] wrapped as coda::mcmc.list object
  level_2:  2-dim array [draw x parameter] wrapped as coda::mcmc.list object
}
\examples{

# Load CDNow event log
data(cdnowElog, package="BTYD")
elog <- data.frame(t(sapply(2:nrow(cdnowElog), function(i) strsplit(as.character(cdnowElog[i,]), split=",")[[1]])))
names(elog) <- c("cust", "sampleid", "date", "cds", "sales")
elog$date <- as.Date(elog$date, "\%Y\%m\%d")

# Transform to CBS (including extra column 'litt')
cbs <- elog2cbs(elog, per="week", T.cal=as.Date("1997-09-30"))

# Pareto/NBD MCMC
set.seed(1)
pnbd.draws <- pnbd.mcmc.DrawParameters(cbs, mcmc=1000, burnin=1000, chains=2, thin=10)
summary(pnbd.draws$level_2)
plot(pnbd.draws$level_2)
summary(pnbd.draws$level_2)$quantiles[, "50\%"]

# Pareto/CNBD MCMC
set.seed(2)
param_init <- params.pnbd.mcmc
param_init$t <- 10
param_init$gamma <- 10
pcnbd.draws <- pcnbd.mcmc.DrawParameters(cbs, mcmc=100, burnin=100, chains=2, thin=2, param_init=param_init)
# Note: MCMC chain should be run longer; for demo purposes we keep runtime short here

plot(pcnbd.draws$level_2, density=FALSE)
plot(pcnbd.draws$level_2, trace=FALSE)

coda::gelman.diag(pcnbd.draws$level_2)
# -> MCMC chains have not converged yet

summary(pcnbd.draws$level_2)$quantiles[, "50\%"]

pcnbd.mcmc.plotRegularityRateHeterogeneity(pcnbd.draws)
# -> very narrow distribution around k=1; 
# CDNow customers purchases indeed seem to follow Poisson process

round(effectiveSize(pcnbd.draws$level_2))
# -> effective sample size are small for such a short chain

# draw future transaction
pnbd.xstar <- pcnbd.mcmc.DrawFutureTransactions(cbs, pnbd.draws, T.star=cbs$T.star)
pcnbd.xstar <- pcnbd.mcmc.DrawFutureTransactions(cbs, pcnbd.draws, T.star=cbs$T.star)

# calculate mean over future transaction draws for each customer
cbs$pnbd.mcmc <- apply(pnbd.xstar, 2, mean)
cbs$pcnbd.mcmc <- apply(pcnbd.xstar, 2, mean)

# calculate P(active)
cbs$pactive.pnbd.mcmc <- apply(pnbd.xstar, 2, function(x) mean(x>0))
cbs$pactive.pcnbd.mcmc <- apply(pcnbd.xstar, 2, function(x) mean(x>0))
}
\seealso{
pcnbd.GenerateData elog2cbs
}

